{"version":3,"sources":["../../../src/auth/interceptors/createRetryInterceptor.js"],"names":["axios","defaultGetBackoffMilliseconds","nthRetry","maximumBackoffMilliseconds","exponentialBackoffSeconds","randomFractionOfASecond","Math","random","backoffSeconds","backoffMilliseconds","round","min","createRetryInterceptor","options","httpClient","create","getBackoffMilliseconds","shouldRetry","error","isRequestError","response","config","defaultMaxRetries","interceptor","Promise","reject","maxRetries","retryRequest","backoffDelay","resolve","setTimeout","request","retryResponse"],"mappings":";;;;AAAA,OAAOA,KAAP,MAAkB,OAAlB,C,CAEA;AACA;;AACA,IAAMC,6BAA6B,GAAG,SAAhCA,6BAAgC,CAACC,QAAD,EAAkD;AAAA,MAAvCC,0BAAuC,uEAAV,KAAU;AACtF;AACA,MAAMC,yBAAyB,YAAG,CAAH,EAAQF,QAAR,CAA/B,CAFsF,CAGtF;;AACA,MAAMG,uBAAuB,GAAGC,IAAI,CAACC,MAAL,EAAhC;AACA,MAAMC,cAAc,GAAGJ,yBAAyB,GAAGC,uBAAnD;AACA,MAAMI,mBAAmB,GAAGH,IAAI,CAACI,KAAL,CAAWF,cAAc,GAAG,IAA5B,CAA5B;AACA,SAAOF,IAAI,CAACK,GAAL,CAASF,mBAAT,EAA8BN,0BAA9B,CAAP;AACD,CARD;;AAUA,IAAMS,sBAAsB,GAAG,SAAzBA,sBAAyB,GAAkB;AAAA,MAAjBC,OAAiB,uEAAP,EAAO;AAC/C,4BAUIA,OAVJ,CACEC,UADF;AAAA,MACEA,UADF,oCACed,KAAK,CAACe,MAAN,EADf;AAAA,8BAUIF,OAVJ,CAEEG,sBAFF;AAAA,MAEEA,sBAFF,sCAE2Bf,6BAF3B;AAAA,6BAUIY,OAVJ,CAIEI,WAJF;AAAA,MAIEA,WAJF,qCAIgB,UAACC,KAAD,EAAW;AACvB,QAAMC,cAAc,GAAG,CAACD,KAAK,CAACE,QAAP,IAAmBF,KAAK,CAACG,MAAhD;AACA,WAAOF,cAAP;AACD,GAPH;AAAA,8BAUIN,OAVJ,CASES,iBATF;AAAA,MASEA,iBATF,sCASsB,CATtB;;AAYA,MAAMC,WAAW;AAAA,uEAAG,kBAAOL,KAAP;AAAA;;AAAA;AAAA;AAAA;AAAA;AACVG,cAAAA,MADU,GACCH,KADD,CACVG,MADU,EAGlB;;AAHkB,kBAIbA,MAJa;AAAA;AAAA;AAAA;;AAAA,gDAKTG,OAAO,CAACC,MAAR,CAAeP,KAAf,CALS;;AAAA;AAAA,kBAQbD,WAAW,CAACC,KAAD,CARE;AAAA;AAAA;AAAA;;AAAA,gDASTM,OAAO,CAACC,MAAR,CAAeP,KAAf,CATS;;AAAA;AAAA,mCAcdG,MAdc,CAahBK,UAbgB,EAahBA,UAbgB,mCAaHJ,iBAbG;;AAgBZK,cAAAA,YAhBY;AAAA,oFAgBG,iBAAOzB,QAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gCACfA,QAAQ,GAAGwB,UADI;AAAA;AAAA;AAAA;;AAAA,2DAGVF,OAAO,CAACC,MAAR,CAAeP,KAAf,CAHU;;AAAA;AAAA;AASXU,0BAAAA,YATW,GASIZ,sBAAsB,CAACd,QAAD,CAT1B,EAUjB;;AAViB;AAAA,iCAWX,IAAIsB,OAAJ,CAAY,UAAAK,OAAO;AAAA,mCAAIC,UAAU,CAACD,OAAD,EAAUD,YAAV,CAAd;AAAA,2BAAnB,CAXW;;AAAA;AAAA;AAAA,iCAaKd,UAAU,CAACiB,OAAX,CAAmBV,MAAnB,CAbL;;AAAA;AAajBW,0BAAAA,aAbiB;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,2DAeVL,YAAY,CAACzB,QAAQ,GAAG,CAAZ,CAfF;;AAAA;AAAA,2DAkBZ8B,aAlBY;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAhBH;;AAAA,gCAgBZL,YAhBY;AAAA;AAAA;AAAA;;AAAA,gDAqCXA,YAAY,CAAC,CAAD,CArCD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAH;;AAAA,oBAAXJ,WAAW;AAAA;AAAA;AAAA,KAAjB;;AAwCA,SAAOA,WAAP;AACD,CAtDD;;AAwDA,eAAeX,sBAAf;AACA,SAASX,6BAAT","sourcesContent":["import axios from 'axios';\n\n// This default algorithm is a recreation of what is documented here\n// https://cloud.google.com/storage/docs/exponential-backoff\nconst defaultGetBackoffMilliseconds = (nthRetry, maximumBackoffMilliseconds = 16000) => {\n  // Retry at exponential intervals (2, 4, 8, 16...)\n  const exponentialBackoffSeconds = 2 ** nthRetry;\n  // Add some randomness to avoid sending retries from separate requests all at once\n  const randomFractionOfASecond = Math.random();\n  const backoffSeconds = exponentialBackoffSeconds + randomFractionOfASecond;\n  const backoffMilliseconds = Math.round(backoffSeconds * 1000);\n  return Math.min(backoffMilliseconds, maximumBackoffMilliseconds);\n};\n\nconst createRetryInterceptor = (options = {}) => {\n  const {\n    httpClient = axios.create(),\n    getBackoffMilliseconds = defaultGetBackoffMilliseconds,\n    // By default only retry outbound request failures (not responses)\n    shouldRetry = (error) => {\n      const isRequestError = !error.response && error.config;\n      return isRequestError;\n    },\n    // A per-request maxRetries can be specified in request config.\n    defaultMaxRetries = 2,\n  } = options;\n\n  const interceptor = async (error) => {\n    const { config } = error;\n\n    // If no config exists there was some other error setting up the request\n    if (!config) {\n      return Promise.reject(error);\n    }\n\n    if (!shouldRetry(error)) {\n      return Promise.reject(error);\n    }\n\n    const {\n      maxRetries = defaultMaxRetries,\n    } = config;\n\n    const retryRequest = async (nthRetry) => {\n      if (nthRetry > maxRetries) {\n        // Reject with the original error\n        return Promise.reject(error);\n      }\n\n      let retryResponse;\n\n      try {\n        const backoffDelay = getBackoffMilliseconds(nthRetry);\n        // Delay (wrapped in a promise so we can await the setTimeout)\n        await new Promise(resolve => setTimeout(resolve, backoffDelay));\n        // Make retry request\n        retryResponse = await httpClient.request(config);\n      } catch (e) {\n        return retryRequest(nthRetry + 1);\n      }\n\n      return retryResponse;\n    };\n\n    return retryRequest(1);\n  };\n\n  return interceptor;\n};\n\nexport default createRetryInterceptor;\nexport { defaultGetBackoffMilliseconds };\n"],"file":"createRetryInterceptor.js"}