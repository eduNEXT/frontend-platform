{"version":3,"sources":["../../src/auth/AxiosJwtTokenService.js"],"names":["Cookies","jwtDecode","axios","logFrontendAuthError","processAxiosErrorAndThrow","createRetryInterceptor","AxiosJwtTokenService","loggingService","tokenCookieName","tokenRefreshEndpoint","httpClient","create","defaults","withCredentials","interceptors","response","use","cookies","refreshRequestPromises","cookieValue","get","e","error","Object","message","customAttributes","responseServerEpochSeconds","undefined","makeRefreshRequest","post","axiosResponse","data","response_epoch_seconds","userIsUnauthenticated","status","remove","decodedJwtToken","browserEpochSeconds","Date","now","browserDriftSeconds","Math","abs","decodeJwtCookie","Error","forceRefresh","isTokenExpired","refresh","token","exp"],"mappings":"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","sourcesContent":["import Cookies from 'universal-cookie';\nimport jwtDecode from 'jwt-decode';\nimport axios from 'axios';\nimport { logFrontendAuthError, processAxiosErrorAndThrow } from './utils';\nimport createRetryInterceptor from './interceptors/createRetryInterceptor';\n\nexport default class AxiosJwtTokenService {\n  static isTokenExpired(token) {\n    return !token || token.exp < Date.now() / 1000;\n  }\n\n  constructor(loggingService, tokenCookieName, tokenRefreshEndpoint) {\n    this.loggingService = loggingService;\n    this.tokenCookieName = tokenCookieName;\n    this.tokenRefreshEndpoint = tokenRefreshEndpoint;\n\n    this.httpClient = axios.create();\n    // Set withCredentials to true. Enables cross-site Access-Control requests\n    // to be made using cookies, authorization headers or TLS client\n    // certificates. More on MDN:\n    // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials\n    this.httpClient.defaults.withCredentials = true;\n    // Add retries to this axios instance\n    this.httpClient.interceptors.response.use(\n      response => response,\n      createRetryInterceptor({ httpClient: this.httpClient }),\n    );\n\n    this.cookies = new Cookies();\n    this.refreshRequestPromises = {};\n  }\n\n  getHttpClient() {\n    return this.httpClient;\n  }\n\n  decodeJwtCookie() {\n    const cookieValue = this.cookies.get(this.tokenCookieName);\n\n    if (cookieValue) {\n      try {\n        return jwtDecode(cookieValue);\n      } catch (e) {\n        const error = Object.create(e);\n        error.message = 'Error decoding JWT token';\n        error.customAttributes = { cookieValue };\n        throw error;\n      }\n    }\n\n    return null;\n  }\n\n  refresh() {\n    let responseServerEpochSeconds = 0;\n\n    if (this.refreshRequestPromises[this.tokenCookieName] === undefined) {\n      const makeRefreshRequest = async () => {\n        let axiosResponse;\n        try {\n          try {\n            axiosResponse = await this.httpClient.post(this.tokenRefreshEndpoint);\n            // eslint-disable-next-line max-len\n            if (axiosResponse.data && axiosResponse.data.response_epoch_seconds) {\n              responseServerEpochSeconds = axiosResponse.data.response_epoch_seconds;\n            }\n          } catch (error) {\n            processAxiosErrorAndThrow(error);\n          }\n        } catch (error) {\n          const userIsUnauthenticated = error.response && error.response.status === 401;\n          if (userIsUnauthenticated) {\n            // Clean up the cookie if it exists to eliminate any situation\n            // where the cookie is not expired but the jwt is expired.\n            this.cookies.remove(this.tokenCookieName);\n            const decodedJwtToken = null;\n            return decodedJwtToken;\n          }\n\n          // TODO: Network timeouts and other problems will end up in\n          // this block of code. We could add logic for retrying token\n          // refreshes if we wanted to.\n          throw error;\n        }\n\n        const browserEpochSeconds = Date.now() / 1000;\n        const browserDriftSeconds = responseServerEpochSeconds > 0\n          ? Math.abs(browserEpochSeconds - responseServerEpochSeconds)\n          : null;\n\n        const decodedJwtToken = this.decodeJwtCookie();\n\n        if (!decodedJwtToken) {\n          // This is an unexpected case. The refresh endpoint should set the\n          //   cookie that is needed.\n          // For more details, see:\n          //   docs/decisions/0005-token-null-after-successful-refresh.rst\n          const error = new Error('Access token is still null after successful refresh.');\n          error.customAttributes = { axiosResponse, browserDriftSeconds, browserEpochSeconds };\n          throw error;\n        }\n\n        return decodedJwtToken;\n      };\n\n      this.refreshRequestPromises[this.tokenCookieName] = makeRefreshRequest().finally(() => {\n        delete this.refreshRequestPromises[this.tokenCookieName];\n      });\n    }\n\n    return this.refreshRequestPromises[this.tokenCookieName];\n  }\n\n  async getJwtToken(forceRefresh = false) {\n    try {\n      const decodedJwtToken = this.decodeJwtCookie(this.tokenCookieName);\n      if (!AxiosJwtTokenService.isTokenExpired(decodedJwtToken) && !forceRefresh) {\n        return decodedJwtToken;\n      }\n    } catch (e) {\n      // Log unexpected error and continue with attempt to refresh it.\n      // TODO: Fix these.  They're still using loggingService as a singleton.\n      logFrontendAuthError(this.loggingService, e);\n    }\n\n    try {\n      return await this.refresh();\n    } catch (e) {\n      // TODO: Fix these.  They're still using loggingService as a singleton.\n      logFrontendAuthError(this.loggingService, e);\n      throw e;\n    }\n  }\n}\n"],"file":"AxiosJwtTokenService.js"}