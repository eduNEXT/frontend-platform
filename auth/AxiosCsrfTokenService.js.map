{"version":3,"file":"AxiosCsrfTokenService.js","names":["axios","getUrlParts","processAxiosErrorAndThrow","AxiosCsrfTokenService","constructor","csrfTokenApiPath","httpClient","create","defaults","withCredentials","headers","csrfTokenCache","csrfTokenRequestPromises","getCsrfToken","url","urlParts","e","global","location","origin","protocol","domain","csrfToken","get","then","response","data","catch","finally","clearCsrfTokenCache","getHttpClient"],"sources":["../../src/auth/AxiosCsrfTokenService.js"],"sourcesContent":["import axios from 'axios';\nimport { getUrlParts, processAxiosErrorAndThrow } from './utils';\n\nexport default class AxiosCsrfTokenService {\n  constructor(csrfTokenApiPath) {\n    this.csrfTokenApiPath = csrfTokenApiPath;\n    this.httpClient = axios.create();\n    // Set withCredentials to true. Enables cross-site Access-Control requests\n    // to be made using cookies, authorization headers or TLS client\n    // certificates. More on MDN:\n    // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials\n    this.httpClient.defaults.withCredentials = true;\n    this.httpClient.defaults.headers['USE-JWT-COOKIE'] = true;\n\n    this.csrfTokenCache = {};\n    this.csrfTokenRequestPromises = {};\n  }\n\n  async getCsrfToken(url) {\n    let urlParts;\n    try {\n      urlParts = getUrlParts(url);\n    } catch (e) {\n      // If the url is not parsable it's likely because a relative\n      // path was supplied as the url. This is acceptable and in\n      // this case we should use the current origin of the page.\n      urlParts = getUrlParts(global.location.origin);\n    }\n\n    const { protocol, domain } = urlParts;\n    const csrfToken = this.csrfTokenCache[domain];\n\n    if (csrfToken) {\n      return csrfToken;\n    }\n\n    if (!this.csrfTokenRequestPromises[domain]) {\n      this.csrfTokenRequestPromises[domain] = this.httpClient\n        .get(`${protocol}://${domain}${this.csrfTokenApiPath}`)\n        .then((response) => {\n          this.csrfTokenCache[domain] = response.data.csrfToken;\n          return this.csrfTokenCache[domain];\n        })\n        .catch(processAxiosErrorAndThrow)\n        .finally(() => {\n          delete this.csrfTokenRequestPromises[domain];\n        });\n    }\n\n    return this.csrfTokenRequestPromises[domain];\n  }\n\n  clearCsrfTokenCache() {\n    this.csrfTokenCache = {};\n  }\n\n  getHttpClient() {\n    return this.httpClient;\n  }\n}\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,WAAW,EAAEC,yBAAyB,QAAQ,SAAS;AAEhE,eAAe,MAAMC,qBAAqB,CAAC;EACzCC,WAAWA,CAACC,gBAAgB,EAAE;IAC5B,IAAI,CAACA,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,UAAU,GAAGN,KAAK,CAACO,MAAM,CAAC,CAAC;IAChC;IACA;IACA;IACA;IACA,IAAI,CAACD,UAAU,CAACE,QAAQ,CAACC,eAAe,GAAG,IAAI;IAC/C,IAAI,CAACH,UAAU,CAACE,QAAQ,CAACE,OAAO,CAAC,gBAAgB,CAAC,GAAG,IAAI;IAEzD,IAAI,CAACC,cAAc,GAAG,CAAC,CAAC;IACxB,IAAI,CAACC,wBAAwB,GAAG,CAAC,CAAC;EACpC;EAEA,MAAMC,YAAYA,CAACC,GAAG,EAAE;IACtB,IAAIC,QAAQ;IACZ,IAAI;MACFA,QAAQ,GAAGd,WAAW,CAACa,GAAG,CAAC;IAC7B,CAAC,CAAC,OAAOE,CAAC,EAAE;MACV;MACA;MACA;MACAD,QAAQ,GAAGd,WAAW,CAACgB,MAAM,CAACC,QAAQ,CAACC,MAAM,CAAC;IAChD;IAEA,MAAM;MAAEC,QAAQ;MAAEC;IAAO,CAAC,GAAGN,QAAQ;IACrC,MAAMO,SAAS,GAAG,IAAI,CAACX,cAAc,CAACU,MAAM,CAAC;IAE7C,IAAIC,SAAS,EAAE;MACb,OAAOA,SAAS;IAClB;IAEA,IAAI,CAAC,IAAI,CAACV,wBAAwB,CAACS,MAAM,CAAC,EAAE;MAC1C,IAAI,CAACT,wBAAwB,CAACS,MAAM,CAAC,GAAG,IAAI,CAACf,UAAU,CACpDiB,GAAG,CAAC,GAAGH,QAAQ,MAAMC,MAAM,GAAG,IAAI,CAAChB,gBAAgB,EAAE,CAAC,CACtDmB,IAAI,CAAEC,QAAQ,IAAK;QAClB,IAAI,CAACd,cAAc,CAACU,MAAM,CAAC,GAAGI,QAAQ,CAACC,IAAI,CAACJ,SAAS;QACrD,OAAO,IAAI,CAACX,cAAc,CAACU,MAAM,CAAC;MACpC,CAAC,CAAC,CACDM,KAAK,CAACzB,yBAAyB,CAAC,CAChC0B,OAAO,CAAC,MAAM;QACb,OAAO,IAAI,CAAChB,wBAAwB,CAACS,MAAM,CAAC;MAC9C,CAAC,CAAC;IACN;IAEA,OAAO,IAAI,CAACT,wBAAwB,CAACS,MAAM,CAAC;EAC9C;EAEAQ,mBAAmBA,CAAA,EAAG;IACpB,IAAI,CAAClB,cAAc,GAAG,CAAC,CAAC;EAC1B;EAEAmB,aAAaA,CAAA,EAAG;IACd,OAAO,IAAI,CAACxB,UAAU;EACxB;AACF","ignoreList":[]}