{"version":3,"file":"AxiosCsrfTokenService.js","names":["axios","getUrlParts","processAxiosErrorAndThrow","AxiosCsrfTokenService","csrfTokenApiPath","httpClient","create","defaults","withCredentials","headers","common","csrfTokenCache","csrfTokenRequestPromises","url","urlParts","e","global","location","origin","protocol","domain","csrfToken","get","then","response","data"],"sources":["../../src/auth/AxiosCsrfTokenService.js"],"sourcesContent":["import axios from 'axios';\nimport { getUrlParts, processAxiosErrorAndThrow } from './utils';\n\nexport default class AxiosCsrfTokenService {\n  constructor(csrfTokenApiPath) {\n    this.csrfTokenApiPath = csrfTokenApiPath;\n    this.httpClient = axios.create();\n    // Set withCredentials to true. Enables cross-site Access-Control requests\n    // to be made using cookies, authorization headers or TLS client\n    // certificates. More on MDN:\n    // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials\n    this.httpClient.defaults.withCredentials = true;\n    this.httpClient.defaults.headers.common['USE-JWT-COOKIE'] = true;\n\n    this.csrfTokenCache = {};\n    this.csrfTokenRequestPromises = {};\n  }\n\n  async getCsrfToken(url) {\n    let urlParts;\n    try {\n      urlParts = getUrlParts(url);\n    } catch (e) {\n      // If the url is not parsable it's likely because a relative\n      // path was supplied as the url. This is acceptable and in\n      // this case we should use the current origin of the page.\n      urlParts = getUrlParts(global.location.origin);\n    }\n\n    const { protocol, domain } = urlParts;\n    const csrfToken = this.csrfTokenCache[domain];\n\n    if (csrfToken) {\n      return csrfToken;\n    }\n\n    if (!this.csrfTokenRequestPromises[domain]) {\n      this.csrfTokenRequestPromises[domain] = this.httpClient\n        .get(`${protocol}://${domain}${this.csrfTokenApiPath}`)\n        .then((response) => {\n          this.csrfTokenCache[domain] = response.data.csrfToken;\n          return this.csrfTokenCache[domain];\n        })\n        .catch(processAxiosErrorAndThrow)\n        .finally(() => {\n          delete this.csrfTokenRequestPromises[domain];\n        });\n    }\n\n    return this.csrfTokenRequestPromises[domain];\n  }\n\n  clearCsrfTokenCache() {\n    this.csrfTokenCache = {};\n  }\n\n  getHttpClient() {\n    return this.httpClient;\n  }\n}\n"],"mappings":";+CACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,WAAW,EAAEC,yBAAyB,QAAQ,SAAS;AAAC,IAE5CC,qBAAqB;EACxC,+BAAYC,gBAAgB,EAAE;IAAA;IAC5B,IAAI,CAACA,gBAAgB,GAAGA,gBAAgB;IACxC,IAAI,CAACC,UAAU,GAAGL,KAAK,CAACM,MAAM,EAAE;IAChC;IACA;IACA;IACA;IACA,IAAI,CAACD,UAAU,CAACE,QAAQ,CAACC,eAAe,GAAG,IAAI;IAC/C,IAAI,CAACH,UAAU,CAACE,QAAQ,CAACE,OAAO,CAACC,MAAM,CAAC,gBAAgB,CAAC,GAAG,IAAI;IAEhE,IAAI,CAACC,cAAc,GAAG,CAAC,CAAC;IACxB,IAAI,CAACC,wBAAwB,GAAG,CAAC,CAAC;EACpC;EAAC;IAAA;IAAA;MAAA,+EAED,iBAAmBC,GAAG;QAAA;QAAA;QAAA;UAAA;YAAA;cAEpB,IAAI;gBACFC,QAAQ,GAAGb,WAAW,CAACY,GAAG,CAAC;cAC7B,CAAC,CAAC,OAAOE,CAAC,EAAE;gBACV;gBACA;gBACA;gBACAD,QAAQ,GAAGb,WAAW,CAACe,MAAM,CAACC,QAAQ,CAACC,MAAM,CAAC;cAChD;cAAC,YAE4BJ,QAAQ,EAA7BK,QAAQ,aAARA,QAAQ,EAAEC,MAAM,aAANA,MAAM;cAClBC,SAAS,GAAG,IAAI,CAACV,cAAc,CAACS,MAAM,CAAC;cAAA,KAEzCC,SAAS;gBAAA;gBAAA;cAAA;cAAA,iCACJA,SAAS;YAAA;cAGlB,IAAI,CAAC,IAAI,CAACT,wBAAwB,CAACQ,MAAM,CAAC,EAAE;gBAC1C,IAAI,CAACR,wBAAwB,CAACQ,MAAM,CAAC,GAAG,IAAI,CAACf,UAAU,CACpDiB,GAAG,WAAIH,QAAQ,gBAAMC,MAAM,SAAG,IAAI,CAAChB,gBAAgB,EAAG,CACtDmB,IAAI,CAAC,UAACC,QAAQ,EAAK;kBAClB,KAAI,CAACb,cAAc,CAACS,MAAM,CAAC,GAAGI,QAAQ,CAACC,IAAI,CAACJ,SAAS;kBACrD,OAAO,KAAI,CAACV,cAAc,CAACS,MAAM,CAAC;gBACpC,CAAC,CAAC,SACI,CAAClB,yBAAyB,CAAC,WACzB,CAAC,YAAM;kBACb,OAAO,KAAI,CAACU,wBAAwB,CAACQ,MAAM,CAAC;gBAC9C,CAAC,CAAC;cACN;cAAC,iCAEM,IAAI,CAACR,wBAAwB,CAACQ,MAAM,CAAC;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CAC7C;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA,OAED,+BAAsB;MACpB,IAAI,CAACT,cAAc,GAAG,CAAC,CAAC;IAC1B;EAAC;IAAA;IAAA,OAED,yBAAgB;MACd,OAAO,IAAI,CAACN,UAAU;IACxB;EAAC;EAAA;AAAA;AAAA,SAvDkBF,qBAAqB"}