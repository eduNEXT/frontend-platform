{"version":3,"sources":["../../src/auth/AxiosCsrfTokenService.js"],"names":["axios","getUrlParts","processAxiosErrorAndThrow","AxiosCsrfTokenService","csrfTokenApiPath","httpClient","create","defaults","withCredentials","headers","common","csrfTokenCache","csrfTokenRequestPromises","url","urlParts","e","global","location","origin","protocol","domain","csrfToken","get","then","response","data"],"mappings":";;;;;;;;;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,WAAT,EAAsBC,yBAAtB,QAAuD,SAAvD;;IAEqBC,qB;AACnB,iCAAYC,gBAAZ,EAA8B;AAAA;;AAC5B,SAAKA,gBAAL,GAAwBA,gBAAxB;AACA,SAAKC,UAAL,GAAkBL,KAAK,CAACM,MAAN,EAAlB,CAF4B,CAG5B;AACA;AACA;AACA;;AACA,SAAKD,UAAL,CAAgBE,QAAhB,CAAyBC,eAAzB,GAA2C,IAA3C;AACA,SAAKH,UAAL,CAAgBE,QAAhB,CAAyBE,OAAzB,CAAiCC,MAAjC,CAAwC,gBAAxC,IAA4D,IAA5D;AAEA,SAAKC,cAAL,GAAsB,EAAtB;AACA,SAAKC,wBAAL,GAAgC,EAAhC;AACD;;;;;kFAED,iBAAmBC,GAAnB;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAEE,oBAAI;AACFC,kBAAAA,QAAQ,GAAGb,WAAW,CAACY,GAAD,CAAtB;AACD,iBAFD,CAEE,OAAOE,CAAP,EAAU;AACV;AACA;AACA;AACAD,kBAAAA,QAAQ,GAAGb,WAAW,CAACe,MAAM,CAACC,QAAP,CAAgBC,MAAjB,CAAtB;AACD;;AATH,4BAW+BJ,QAX/B,EAWUK,QAXV,aAWUA,QAXV,EAWoBC,MAXpB,aAWoBA,MAXpB;AAYQC,gBAAAA,SAZR,GAYoB,KAAKV,cAAL,CAAoBS,MAApB,CAZpB;;AAAA,qBAcMC,SAdN;AAAA;AAAA;AAAA;;AAAA,iDAeWA,SAfX;;AAAA;AAkBE,oBAAI,CAAC,KAAKT,wBAAL,CAA8BQ,MAA9B,CAAL,EAA4C;AAC1C,uBAAKR,wBAAL,CAA8BQ,MAA9B,IAAwC,KAAKf,UAAL,CACrCiB,GADqC,WAC9BH,QAD8B,gBAChBC,MADgB,SACP,KAAKhB,gBADE,GAErCmB,IAFqC,CAEhC,UAACC,QAAD,EAAc;AAClB,oBAAA,KAAI,CAACb,cAAL,CAAoBS,MAApB,IAA8BI,QAAQ,CAACC,IAAT,CAAcJ,SAA5C;AACA,2BAAO,KAAI,CAACV,cAAL,CAAoBS,MAApB,CAAP;AACD,mBALqC,WAM/BlB,yBAN+B,aAO7B,YAAM;AACb,2BAAO,KAAI,CAACU,wBAAL,CAA8BQ,MAA9B,CAAP;AACD,mBATqC,CAAxC;AAUD;;AA7BH,iDA+BS,KAAKR,wBAAL,CAA8BQ,MAA9B,CA/BT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WAkCA,+BAAsB;AACpB,WAAKT,cAAL,GAAsB,EAAtB;AACD;;;WAED,yBAAgB;AACd,aAAO,KAAKN,UAAZ;AACD;;;;;;SAvDkBF,qB","sourcesContent":["import axios from 'axios';\nimport { getUrlParts, processAxiosErrorAndThrow } from './utils';\n\nexport default class AxiosCsrfTokenService {\n  constructor(csrfTokenApiPath) {\n    this.csrfTokenApiPath = csrfTokenApiPath;\n    this.httpClient = axios.create();\n    // Set withCredentials to true. Enables cross-site Access-Control requests\n    // to be made using cookies, authorization headers or TLS client\n    // certificates. More on MDN:\n    // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials\n    this.httpClient.defaults.withCredentials = true;\n    this.httpClient.defaults.headers.common['USE-JWT-COOKIE'] = true;\n\n    this.csrfTokenCache = {};\n    this.csrfTokenRequestPromises = {};\n  }\n\n  async getCsrfToken(url) {\n    let urlParts;\n    try {\n      urlParts = getUrlParts(url);\n    } catch (e) {\n      // If the url is not parsable it's likely because a relative\n      // path was supplied as the url. This is acceptable and in\n      // this case we should use the current origin of the page.\n      urlParts = getUrlParts(global.location.origin);\n    }\n\n    const { protocol, domain } = urlParts;\n    const csrfToken = this.csrfTokenCache[domain];\n\n    if (csrfToken) {\n      return csrfToken;\n    }\n\n    if (!this.csrfTokenRequestPromises[domain]) {\n      this.csrfTokenRequestPromises[domain] = this.httpClient\n        .get(`${protocol}://${domain}${this.csrfTokenApiPath}`)\n        .then((response) => {\n          this.csrfTokenCache[domain] = response.data.csrfToken;\n          return this.csrfTokenCache[domain];\n        })\n        .catch(processAxiosErrorAndThrow)\n        .finally(() => {\n          delete this.csrfTokenRequestPromises[domain];\n        });\n    }\n\n    return this.csrfTokenRequestPromises[domain];\n  }\n\n  clearCsrfTokenCache() {\n    this.csrfTokenCache = {};\n  }\n\n  getHttpClient() {\n    return this.httpClient;\n  }\n}\n"],"file":"AxiosCsrfTokenService.js"}